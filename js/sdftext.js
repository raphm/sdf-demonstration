

// This is the logical core of the signed distance field renderer. This was
// pretty much a straight translation from C++, so it should be an easy
// port to the language of your choice.


var sdftext = {};

sdftext.vert_src = [
  "attribute vec3 avecpos;",
  "attribute vec2 auvpos;",
  "uniform mat4 uPMatrix;",
  "uniform mat4 uMVMatrix;",
  "uniform sampler2D texture;",
  "varying vec2 vUv;",
  "void main() {",
    "vUv=auvpos;",
    "gl_Position = uPMatrix * uMVMatrix * vec4(avecpos, 1.0);",
  "}"
].join("\n");

sdftext.frag_src = [
  "precision mediump float;",
  "uniform float time;",
  "uniform sampler2D texture;",
  "varying vec2 vUv;",
  "const vec3 glyphcolor = vec3(1.0, 1.0, 1.0);",
  "const vec3 glowcolor = vec3(0.2, 0, 1.0);",
  "void main() {",
    "vec4 tx = texture2D(texture, vUv);",
    "float mask = tx.r;",
    "float delta = 0.1;",
    "float finalalpha = smoothstep(0.5-delta,0.5+delta,mask);",
    "vec4 clr;",
    "clr = vec4(glyphcolor, finalalpha);",
    "if(time>0.0) {", // <--- This is bad. Leaving it here to illustrate the howto...
    "  clr.rgb = mix(glowcolor, glyphcolor, finalalpha);",
    "  float alpha = smoothstep(0.0, 0.5+(0.6*(time*0.5)), sqrt(mask));",
    "  clr.a = alpha;",
    "}",
    "gl_FragColor = clr;",
  "}"
].join("\n");

// Note that it is BAD practice to have conditionals in shaders!!! This is for
// didactic purposes only. If you want glowing borders, there are far
// more efficient ways to do it.

sdftext.init_shaders = function() {

  sdftext.shader_prog = {};

  initShaders(sdftext.shader_prog, sdftext.frag_src, sdftext.vert_src);

  initAttrib(sdftext.shader_prog, "avecpos");
  gl.enableVertexAttribArray(sdftext.shader_prog["avecpos"]);

  initAttrib(sdftext.shader_prog, "auvpos");
  gl.enableVertexAttribArray(sdftext.shader_prog["auvpos"]);

  initUniform(sdftext.shader_prog, "time");
  initUniform(sdftext.shader_prog, "uPMatrix");
  initUniform(sdftext.shader_prog, "uMVMatrix");
  initUniform(sdftext.shader_prog, "texture");

}

sdftext.init_textures = function() {
  sdftext.texture = initTexture("mensch.png", gl.LINEAR, gl.LINEAR, true);
  // This is the signed distance field texture that was generated by
  // makeglfont (https://github.com/raphm/makeglfont).
}

sdftext.init_anim = function() {
  sdftext.forward = false;
  sdftext.backward = false;
  sdftext.left = false;
  sdftext.right = false;
  sdftext.up = false;
  sdftext.down = false;
  sdftext.glow = false;
}

sdftext.handle_keys = function() {
  sdftext.forward = false;
  sdftext.backward = false;
  sdftext.left = false;
  sdftext.right = false;
  sdftext.up = false;
  sdftext.down = false;
  if (currentlyPressedKeys[87]) {
    // W
    sdftext.forward = true;
  }
  if (currentlyPressedKeys[68]) {
    // A
    sdftext.left = true;
  }
  if (currentlyPressedKeys[83]) {
    // S
    sdftext.backward = true;
  }
  if (currentlyPressedKeys[65]) {
    // D
    sdftext.right = true;
  }
  if(currentlyPressedKeys[71]) {
    // G
    sdftext.glow = true;
  }
  if(currentlyPressedKeys[72]) {
    // H
    sdftext.glow = false;
  }
  if(currentlyPressedKeys[81]) {
    // Q
    sdftext.up = true;
  }
  if(currentlyPressedKeys[69]) {
    // E
    sdftext.down = true;
  }
}

sdftext.position={};
sdftext.position.z = -5.0;
sdftext.position.y = 0;
sdftext.position.x = 0;
sdftext.time = 0;

sdftext.animate = function(time_delta) {
  var speed = 4;
  sdftext.time += (time_delta*0.001);
  while(sdftext.time>3.141) {sdftext.time-=3.141;}
  var movedelta = time_delta*0.001*speed;
  if(sdftext.forward) {
    sdftext.position.z += movedelta;
  }
  if(sdftext.backward) {
    sdftext.position.z -= movedelta;
  }
  if(sdftext.left) {
    sdftext.position.x += movedelta;
  }
  if(sdftext.right) {
    sdftext.position.x -= movedelta;
  }
  if(sdftext.up) {
    sdftext.position.y += movedelta;
  }
  if(sdftext.down) {
    sdftext.position.y -= movedelta;
  }
}

function loadJSON(font_url, callback) {
  var xobj = new XMLHttpRequest();
  xobj.overrideMimeType("application/json");
  xobj.open('GET', font_url, true);
  console.log(font_url);
  xobj.onreadystatechange = function () {
    if (xobj.readyState == 4) {
      // Required use of an anonymous callback
      // .open does not return a value, but instead
      // returns undefined in async mode
      callback(JSON.parse(xobj.responseText));
    }
  };
  xobj.send(null);
}

function create_font_metrics(f) {
  var metrics = {};
  console.log("Loading font " + f.name);

  metrics.size = f.size;
  metrics.height = f.height;
  metrics.ascender = f.ascender;
  metrics.descender = f.descender;
  metrics.max_advance = f.max_advance;
  metrics.space_advance = f.space_advance;

  var glyphs = {};

  for(var g in f.glyph_data) {
    glyphs[g]=f.glyph_data[g];
  };

  metrics.glyph_data = glyphs;

  return metrics;
}

sdftext.init_buffers = function() {
  sdftext.drawable = false;
  // 'mensch.json' is the font metrics file generated by
  // makeglfont (https://github.com/raphm/makeglfont).
  loadJSON('mensch.json', function (json) {
    fontmetrics=create_font_metrics(json);
    sdftext.do_init_buffers();
    sdftext.drawable = true;
 });
}

sdftext.text_to_draw = "";
sdftext.font_size = 1;

sdftext.set_text = function(t) {
  sdftext.text_to_draw = t;
}

sdftext.set_font_size = function(s) {
  sdftext.font_size = s;
}

sdftext.do_init_buffers = function() {

  if(!sdftext.text_to_draw) {
    return;
  }

  var pen_x = 0.0;
  var pen_y = 0.0;
  var font_size = sdftext.font_size;
  var vertices = [];
  var texcoords = [];
  var indices = [];

  for (var i=0; i<sdftext.text_to_draw.length; ++i) {

    var glyph = fontmetrics.glyph_data[sdftext.text_to_draw[i]];

    if(glyph) {

      var kernval = 0;

      if(i>0) {
        var kernchar = sdftext.text_to_draw[i-1];
        kernval = glyph.kernings[kernchar];
        if(kernval && (kernval<-0.001 || kernval>0.001)) {
          pen_x += kernval * font_size;
        }
      }

      var g_width = glyph.bbox_width*font_size;
      var g_height = glyph.bbox_height*font_size;
      var g_bearing_x = glyph.bearing_x*font_size;
      var g_bearing_y = glyph.bearing_y*font_size;
      var g_advance_x = glyph.advance_x*font_size;

      var x = pen_x + g_bearing_x;
      var y = pen_y + g_bearing_y;
      var w = g_width;
      var h = g_height;

      // We handle texture coordinates (which start from the top...) like this:
      //  s0,t0  ---- s1,t0
      //         |\ |
      //         | \|
      //  s0,t1  ---- s1,t1
      //
      // For an "upright" glyph, we need two counterclockwise triangles:
      //   Triangle 1: 0,0 ; 1,0 ; 0,1 (see below --- our first face)
      //   Triangle 2: 1,0 ; 1,1 ; 0,1 (see below --- our second face)
      // Which translates to:
      //   s0,t1; s1,t1; s0,t0 (first triangle texcoords)
      //   s1,t1; s1,t0; s0,t0
      //
      // And the vertex coords are:
      //   0,0 ;  1,0;  0,1
      //   1,0 ;  1,1;  0,1
      //
      // So, the order of the four texcoords is:
      //  s0,t1; s1,t1; s0,t0; s1,t0
      //
      // And the order of the four vertices is:
      //   0,0;  1,0;  0,1;  1,1;

      vertices.push(x,   y-h, 0);   // 0,0
      vertices.push(x+w, y-h, 0);   // 1,0
      vertices.push(x,   y, 0);     // 0,1
      vertices.push(x+w, y, 0);   // 1,1

      texcoords.push(glyph.s0, glyph.t1);
      texcoords.push(glyph.s1, glyph.t1);
      texcoords.push(glyph.s0, glyph.t0);
      texcoords.push(glyph.s1, glyph.t0);

      var curidx = i*4;
      indices.push(curidx+0, curidx+1, curidx+2); // first triangle
      indices.push(curidx+1, curidx+3, curidx+2); // second triangle

      pen_x += g_advance_x;

    } else {
      pen_x += fontmetrics.space_advance;
    }

  }

  sdftext.vertex_position_buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, sdftext.vertex_position_buffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
  sdftext.vertex_position_buffer.itemSize = 3;
  sdftext.vertex_position_buffer.numItems = vertices.length/3;

  sdftext.vertex_texcoord_buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, sdftext.vertex_texcoord_buffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);
  sdftext.vertex_texcoord_buffer.itemSize = 2;
  sdftext.vertex_texcoord_buffer.numItems = texcoords.length/2;

  sdftext.vertex_index_buffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sdftext.vertex_index_buffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
  sdftext.vertex_index_buffer.itemSize = 1;
  sdftext.vertex_index_buffer.numItems = indices.length;

}

sdftext.draw = function() {
  if(!sdftext.drawable) {
    return;
  }

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, sdftext.texture);
  gl.useProgram(sdftext.shader_prog.shaderProgID);
  gl.uniform1i(sdftext.shader_prog["texture"], 0);

  mat4.perspective(pMatrix, 45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);

  mat4.identity(mvMatrix);

  mat4.translate(mvMatrix, mvMatrix, [0.0, 0.0, sdftext.position.z]);
  mat4.translate(mvMatrix, mvMatrix, [0.0, sdftext.position.y, 0.0]);
  mat4.translate(mvMatrix, mvMatrix, [sdftext.position.x, 0.0, 0.0]);

  gl.bindBuffer(gl.ARRAY_BUFFER, sdftext.vertex_position_buffer);
  gl.vertexAttribPointer(sdftext.shader_prog["avecpos"],
    sdftext.vertex_position_buffer.itemSize, gl.FLOAT, false, 0, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, sdftext.vertex_texcoord_buffer);
  gl.vertexAttribPointer(sdftext.shader_prog["auvpos"],
    sdftext.vertex_texcoord_buffer.itemSize, gl.FLOAT, false, 0, 0);

  var blending = true;
  if (blending) {
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
    gl.enable(gl.BLEND);
    gl.disable(gl.DEPTH_TEST);
  } else {
    gl.disable(gl.BLEND);
    gl.enable(gl.DEPTH_TEST);
  }

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sdftext.vertex_index_buffer);

  gl.uniformMatrix4fv(sdftext.shader_prog["uPMatrix"], false, pMatrix);
  gl.uniformMatrix4fv(sdftext.shader_prog["uMVMatrix"], false, mvMatrix);
  var tmptime = 0.0;
  if(sdftext.glow) {
    var tmptime = Math.abs(Math.sin(sdftext.time));
  }
  gl.uniform1f(sdftext.shader_prog["time"], tmptime);

  gl.drawElements(gl.TRIANGLES, sdftext.vertex_index_buffer.numItems, gl.UNSIGNED_SHORT, 0);

}
